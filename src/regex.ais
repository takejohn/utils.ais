:: Regex {
    /**
     * @callback Regex
     * @param {str} input 入力文字列
     * @param {num} from 開始位置
     * @returns {Result | null} 検索結果
     */

    /**
     * @typedef {obj} Result
     * @prop {num} start 一致した文字列の開始位置
     * @prop {num} end 一致した文字列の終了位置
     * @prop {@() => Result | null} backtrack バックトラックを行う関数
     */

    /**
     * 正規表現をコンパイルする。
     * @param {str} pattern 正規表現パターン
     * @returns {Regex} コンパイル済み正規表現
     */
    @compile(pattern: str): obj {
        if (Core:type(pattern) != 'str') {
            Core:abort('Regex:compile の第1引数は文字列である必要があります。')
        }
        _literal(pattern)
    }

    /**
     * @param {Regex} regex コンパイル済み正規表現
     * @param {str} input 対象の文字列
     * @returns {num} 指定された文字列の中で正規表現に最初に一致した位置。
     *                一致する文字列が見つからなかった場合、-1。
     */
    @search(regex: obj, input: str): num {
        let result = regex(input, 0)
        if result == null {
            -1
        } else {
            result.start
        }
    }

    /**
     * @param {Regex} regex コンパイル済み正規表現
     * @param {str} input 対象の文字列
     * @returns {bool} 指定された文字列の中に正規表現に一致する部分文字列があった場合、true。
     *                 そうでなければ、false
     */
    @test(regex: obj, input: str): bool {
        regex(input, 0) != null
    }

    @_NULL(): null {
        null
    }

    /**
     * 文字列に完全一致する正規表現。
     * @returns {Regex}
     */
    @_literal(s: str): @(str, num) => any {
        @(input: str, from: num): any {
            let start = input.index_of(s, from)
            if start < 0 {
                null
            } else {
                { start: start, end: start + s.len, backtrack: _NULL }
            }
        }
    }
}
